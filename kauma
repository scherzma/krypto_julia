#!/usr/bin/env python3
import base64
import json
import sys
from functools import reduce
from textwrap import indent

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes


def poly2block(case):
    if case["arguments"]["semantic"] == "xex":
        return {"block": tobase64l(coefficients2numberXEX(case["arguments"]["coefficients"]))}
    elif case["arguments"]["semantic"] == "gcm":
        res = coefficients2numberGCM(case["arguments"]["coefficients"])
        res_bytes = res.to_bytes(16, byteorder='big')
        return {"block": base64.b64encode(res_bytes).decode('utf-8')}

def block2poly(case):
    if case["arguments"]["semantic"] == "xex":
        return {"coefficients": number2coefficientsXEX(frombase64(case["arguments"]["block"]))}
    elif case["arguments"]["semantic"] == "gcm":
        number = reverse_endian(frombase64(case["arguments"]["block"]))
        return {"coefficients": number2coefficientsGCM(number)}


def coefficients2numberGCM(coefficients):
    res = 0
    for coefficient in coefficients:
        res |= 1 << 127 - coefficient
    return res

def number2coefficientsGCM(number):
    coefficients = []
    for i in range(number.bit_length()):
        if number & 1 << i:
            coefficients.append(127 - i)
    return coefficients

coefficients2numberXEX = lambda coefficients: sum(1 << i for i in coefficients)
number2coefficientsXEX = lambda number: [i for i in range(number.bit_length()) if number & (1 << i)]
add_numbers = lambda case: {"sum": case["arguments"]["number1"] + case["arguments"]["number2"]}
subtract_numbers = lambda case: {"difference": case["arguments"]["number1"] - case["arguments"]["number2"]}
frombase64 = lambda s: int.from_bytes(base64.b64decode(s), byteorder='little')
tobase64l = lambda number: base64.b64encode(number.to_bytes(16, byteorder='little')).decode('utf-8')
tobase64b = lambda number: base64.b64encode(number.to_bytes(16, byteorder='big')).decode('utf-8')
reverse_endian = lambda num, bytes_length=16: int.from_bytes(num.to_bytes(bytes_length, byteorder='little'), byteorder='big')


def gfmul_int(a, b, modulus=0x100000000000000000000000000000087):
    res = reduce(lambda x,i: x ^ ((a << i) if b & (1 << i) else 0), range(b.bit_length()), 0)
    return reduce(lambda x,i: x ^ ((modulus << (i - 128)) if x & (1 << i) else 0), range(res.bit_length()-1, 127, -1), res)

def gfmul(case, modulus=0x100000000000000000000000000000087):
    a, b = frombase64(case["arguments"]["a"]), frombase64(case["arguments"]["b"])
    return {"product": tobase64l(gfmul_int(a, b, modulus))}

def sea128_int(mode, key_bytes, input_bytes):
    sea128_const = 0xc0ffeec0ffeec0ffeec0ffeec0ffee11


    cipher = Cipher(algorithms.AES(key_bytes), modes.ECB())

    if mode == "encrypt":
        encryptor = cipher.encryptor()
        aes_result = encryptor.update(input_bytes) + encryptor.finalize()
        int_result = int.from_bytes(aes_result, byteorder='big') ^ sea128_const

    elif mode == "decrypt":
        input_int = int.from_bytes(input_bytes, byteorder='big')
        xored = input_int ^ sea128_const
        xored_bytes = xored.to_bytes(16, byteorder='big')
        decryptor = cipher.decryptor()
        final_bytes = decryptor.update(xored_bytes) + decryptor.finalize()
        int_result = int.from_bytes(final_bytes, byteorder='big')

    return int_result

def sea128(case):
    arguments = case["arguments"]
    mode = arguments["mode"]
    key = arguments["key"]
    input_data = arguments["input"]

    key_bytes = base64.b64decode(key)
    input_bytes = base64.b64decode(input_data)
    return {"output": tobase64b(sea128_int(mode, key_bytes, input_bytes))}


def fde_xex(key_bytes, tweak_bytes, input_bytes, mode):
    k1 = key_bytes[:16]
    k2 = key_bytes[16:]

    if len(key_bytes) != 32:
        raise ValueError("Key must be 256 bits (32 bytes) for XEX.")

    mask = sea128_int("encrypt", k2, tweak_bytes)
    output_bytes = bytearray()

    for i in range(len(input_bytes) // 16):
        block = input_bytes[i * 16:(i + 1) * 16]
        block_int = int.from_bytes(block, byteorder='big')
        temp = block_int ^ mask

        temp_bytes = temp.to_bytes(16, byteorder='big')

        temp_encrypted_int = sea128_int(mode, k1, temp_bytes)

        plaintext = temp_encrypted_int ^ mask
        output_bytes += plaintext.to_bytes(16, byteorder='big')

        mask = reverse_endian(gfmul_int(reverse_endian(mask),2))

    return output_bytes



def xex(case):
    args = case["arguments"]
    mode = args["mode"]
    key = args["key"]
    tweak = args["tweak"]
    input_data = args["input"]

    key_bytes = base64.b64decode(key)
    tweak_bytes = base64.b64decode(tweak)
    input_bytes = base64.b64decode(input_data)

    result = fde_xex(key_bytes, tweak_bytes, input_bytes, mode)
    return {"output": base64.b64encode(result).decode('utf-8')}



file = "./sample.json"
if len(sys.argv) > 1:
    file = sys.argv[1]

with open(file, "r") as f:
    data = json.load(f)

action_functions = {
    "add_numbers": add_numbers,
    "subtract_numbers": subtract_numbers,
    "poly2block": poly2block,
    "block2poly": block2poly,
    "gfmul": gfmul,
    "sea128": sea128,
    "xex": xex,
}

response = {}
for id, testcase in data["testcases"].items():
    action = testcase["action"]
    func = action_functions.get(action)
    if func:
        response[id] = func(testcase)
    else:
        print(f"Warning: Unknown action '{action}' for testcase {id}")

print(json.dumps({"responses":response}, indent=1))


